YASL Scripting Draft
====================

This is a draft of how the YASL scripting language works.

First off, there are only 2 different types of commands: Assigning a variable, or running it.

In C, semicolons (;) say that a statement is ended. In YASL, this is a comma (,).

Comments are specified by paranthesis ().

There are a few scalar data types:

 * boolean
 * float (either 'float' or 'double' in C. Defaults to 'double')
 * string (Char dynamic array in C)

There is one non-scalar data type:

 * scope

Example code:

    float = 3.5,
    int = 3, (This is also a 'float')
    string = "hi",
    boolean = true,
    0 = "test", (You can assign numbers as variable names. HOWEVER, you can't access them normally, as is demonstated by the next example)
    value_of_0 = .["0"],
    also_value_of_0 = .{0},
    (Note that running .["boolean"] or .{value_of_0} will give the same results as boolean or value_of_0.)
    (This is an alternate way of accessing variables)
    (. is the current scope)
    list = {0 = "test", 1 = "hi", 2 = "hola", 3 = "hello"}, (This is a scope, made as an array)
    info = {
        firstname = "John",
        lastname = "Doe",
        phonenumber = 555 1234 (You can use spaces within numbers if you want)
    },
    firstname = info["test"],
    also_firstname = info{test},
    function = %{ (%{ will create a "blueprint" scope. This is a scope that doesn't have any immediate values [i.e. you can't get the value of function{a_variable}], but is used to create other scopes)
        a_variable = "test",
        @print{printme = a_variable} (Notice that "print" is namespaced. This is because it's native code. @print is NOT included by default with YASL!)
        @return = {printed = true} ("return" is namespaced too because it's a special variable. Normally @return is set to the scope itself [.], but in this case, @return is set to a new scope)
    },
    newscope = function{}, (Creates a new scope, and runs each command one by one)
    (What does newscope contain? {printed = true})
    (Also notice that "function{}" without assigning it to a variable is legal too)
    function{a_variable = "not a test"} (This will replace a_variable with "not a test")
    ascope = { (Because this is not a blueprint, this will run @print without needing to invoke "ascope{}")
        test = "hi",
        @print{printme = test}
    },
    anotherscope = ascope{}, (anotherscope now contains a copy of ascope, since @return is .)
    yetanotherscope = ascope, (yetanotherscope now contains a _reference_ to ascope)
    not_a_reference = boolean, (not_a_reference is aptly named. Only scopes can be referenced)
    boolean_test = {boolean = boolean}, (YASL interprets from right to left, so 'boolean' in this scope doesn't exist when it's trying to search for 'boolean'. So it uses 'boolean' from the parent scope)
    a_reference = boolean_test, (This is how you reference a scalar variable)
    scopes_test = {
        boolean = boolean, (Parent boolean is used)
        another_boolean = boolean (This boolean is used)
        (But what if we want to use the parent boolean?)
        parent_boolean = ..{boolean} (.. is the parent scope)
    }
